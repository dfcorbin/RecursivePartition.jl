<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Polynomial Chaos Basis · RecursivePartition.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RecursivePartition.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Polynomial Basis Expansion</span><ul><li><a class="tocitem" href="../legendre/">Legendre Polynomials</a></li><li class="is-active"><a class="tocitem" href>Polynomial Chaos Basis</a><ul class="internal"><li><a class="tocitem" href="#Definition"><span>Definition</span></a></li><li><a class="tocitem" href="#Implementation-Details"><span>Implementation Details</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Polynomial Basis Expansion</a></li><li class="is-active"><a href>Polynomial Chaos Basis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Polynomial Chaos Basis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/dfcorbin/RecursivePartition.jl/blob/master/docs/src/pcb.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Polynomial-Chaos-Basis"><a class="docs-heading-anchor" href="#Polynomial-Chaos-Basis">Polynomial Chaos Basis</a><a id="Polynomial-Chaos-Basis-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-Chaos-Basis" title="Permalink"></a></h1><h2 id="Definition"><a class="docs-heading-anchor" href="#Definition">Definition</a><a id="Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Definition" title="Permalink"></a></h2><p>The Polynomial Chaos Basis (PCB) is a natural way of extending univariate polynomial bases to the multivariate setting. I will provide a brief introduction to the PCB and how it is constructed, but I will make no attempt to motivate its applications. Upon completion of this documentation I will reference a more detailed summary of PCB applications and theoretical properties.</p><p>Let <span>$ϕ_j(x)$</span> denote a univariate polynomial of degree <span>$j \in \mathbb{N}_{≥ 0 }$</span> e.g. <span>$ϕ_2(x) = x^2$</span> using the Power Basis. We use this notation as there are other univariate bases to choose from, some of which possess useful theoretical properties like orthogonality (see <a href="../legendre/#Legendre-Polynomials">Legendre Polynomials</a>). One way of defining a multivariate polynomial (MVP) is to take a multiplicative combination of univariate polynomials. This can be indexed using a vector of non-negative integers as follows. Let <span>$\boldsymbol{α} = [1, 3, 5]$</span>, the corresponding 3-dimensional multivariate polynomial is given by</p><p class="math-container">\[  \psi_\boldsymbol{α}(\boldsymbol{x}) = ϕ_1(x_1) \cdot ϕ_3(x_2) \cdot ϕ_5(x_3).\]</p><p>The <span>$d$</span>-dimensional PCB is then defined as the collection of all MVPs which can be indexed in this way.</p><p class="math-container">\[  \lbrace ψ_{\boldsymbol{α}} \quad : \quad \boldsymbol{α} \in \mathbb{N}_{≥ 0}^d \rbrace\]</p><p>However, in practice this basis must be truncated in order to be used. This can be achieved by restricting the total degree (defined as the sum of the elements in <span>$\boldsymbol{α})$</span>) of the MVPs.</p><p class="math-container">\[  \lbrace ψ_{\boldsymbol{\alpha}} \quad : \quad \|\boldsymbol{\alpha}\|_1 \leqq J,
  \text{ } \boldsymbol{\alpha} \in \mathbb{N}_{\geqq 0}^d \rbrace.\]</p><p>Now suppose you have an <span>$n \times d$</span> matrix <span>$\boldsymbol{X}$</span> of real numbers. Each row of <span>$\boldsymbol{X}$</span> is a vector on which we can evaluate a MVP. We can therefore construct a new matrix where the entry in the <span>$i$</span>&#39;th row and <span>$j$</span>&#39;th column is the <span>$i$</span>&#39;th row of <span>$\boldsymbol{X}$</span> evaluated at the <span>$j$</span>&#39;th basis function in our PCB i.e. each column of the transformed matrix corresponds to a different MVP in the truncated PCB. This matrix is what we refer to as the &quot;PCB expansion&quot; of <span>$\boldsymbol{X}$</span>.</p><p class="math-container">\[\boldsymbol{Ψ}_{i,j} = ψ_{\boldsymbol{α}_j}(\boldsymbol{x}_i)\]</p><h2 id="Implementation-Details"><a class="docs-heading-anchor" href="#Implementation-Details">Implementation Details</a><a id="Implementation-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-Details" title="Permalink"></a></h2><p>Currently, I have only implemented the <a href="../legendre/#Legendre-Polynomials">Legendre Polynomials</a> variant of the PCB. Since the Legendre Polynomials are only defined on <span>$[-1, 1]$</span>, the user must provide upper/lower bounds for each column of <span>$\boldsymbol{X}$</span> (it is assumed that each column is uniformly distributed between these bounds). These bounds are used to rescale the columns so that they are all uniformly distributed on <span>$[-1, 1]$</span>. Bounds are provided as a <span>$d \times 2$</span> matrix. For example, if <span>$d = 2$</span>, <span>$x_1 \in [0, 1]$</span> and <span>$x_2 \in [1, 2]$</span>, the bounds are represented as</p><p class="math-container">\[\begin{pmatrix}
  0 &amp; 1 \\
  1 &amp; 2
\end{pmatrix}\]</p><p>Constructing the PCB expansion of a matrix using <a href="#RecursivePartition.trunc_pcbmat-Tuple{Array{Float64,2},Int64,Array{Float64,2}}"><code>RecursivePartition.trunc_pcbmat</code></a> is then straightforward.</p><pre><code class="language-julia">using RecursivePartition

X = [0.0 0.5; -0.5 0.0]
kmat = repeat([-1.0 1.0], 2, 1)

trunc_pcbmat(X, 2, kmat)

# output

2×5 Array{Float64,2}:
 0.5  -0.125   0.0   0.0  -0.5
 0.0  -0.5    -0.5  -0.0  -0.125</code></pre><p>If there are specific MVPs you wish to use in the basis expansion (as opposed to the full truncated PCB), this is achieved using <a href="#RecursivePartition.index_pcbmat-Tuple{Array{Float64,2},Array{MVPIndex,1},Array{Float64,2}}"><code>RecursivePartition.index_pcbmat</code></a>. This function accepts a vector of <a href="#RecursivePartition.MVPIndex"><code>RecursivePartition.MVPIndex</code></a> objects which correspond to your choice of MVPs. To construct such an object, we supply two vectors of even length, the first gives the degree of each multiplicative term in the MVP, the second gives the covariate it applies to. For example, to store the MVP</p><p class="math-container">\[ϕ_1(x_1) ⋅ ϕ_3(x_2)\]</p><p>we create the object</p><pre><code class="language-julia">MVPIndex([1, 3], [1, 2])</code></pre><p>This may seem like an odd method for storing an MVP, but it turns out to be far more memory efficient than other methods in higher dimensions. As an alternative to manually constructing <a href="#RecursivePartition.MVPIndex"><code>RecursivePartition.MVPIndex</code></a> objects, you can generate the full truncated PCB basis using <a href="#RecursivePartition.mvpindex-Tuple{Int64,Int64}"><code>RecursivePartition.mvpindex</code></a> and select the basis functions you wish to use.</p><pre><code class="language-julia">mvpindex(2, 2) # 2D PCB basis trunacted with J = 2

# output

5-element Array{MVPIndex,1}:
 MVPIndex([1], [2])
 MVPIndex([2], [2])
 MVPIndex([1], [1])
 MVPIndex([1, 1], [1, 2])
 MVPIndex([2], [1])</code></pre><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RecursivePartition.MVPIndex" href="#RecursivePartition.MVPIndex"><code>RecursivePartition.MVPIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MVPIndex(deg::Vector{Int64}, dim::Vector{Int64})</code></pre><p>Compact structure used to index a multivariate polynomial (MVP).</p><p>It is assumed that this type is primarily constructed using <a href="#RecursivePartition.mvpindex-Tuple{Int64,Int64}"><code>mvpindex</code></a> and supplied to <a href="#RecursivePartition.index_pcbmat-Tuple{Array{Float64,2},Array{MVPIndex,1},Array{Float64,2}}"><code>index_pcbmat</code></a> to perform a polynomial basis expansion.</p><ul><li><code>deg</code> gives the degree of each multiplicative term in the MVP.</li><li><code>dim</code> gives the covariate associated with each degree.</li></ul><p>See also: <a href="#RecursivePartition.mvpindex-Tuple{Int64,Int64}"><code>mvpindex</code></a>, <a href="#RecursivePartition.index_pcbmat-Tuple{Array{Float64,2},Array{MVPIndex,1},Array{Float64,2}}"><code>index_pcbmat</code></a></p><p><strong>Examples</strong></p><p>Let&#39;s suppose we have the vector <span>$\boldsymbol{x} = [x_1, x_2]$</span> and we wish to index the multivariate polynomial <span>$x_1^2 x_2^3$</span>. This is achieved using the following object.</p><pre><code class="language-julia">MVPIndex([2, 3], [1, 2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dfcorbin/RecursivePartition.jl/blob/baed2bfb0913c5fbabb6e36014602956b47f7819/src/pcb.jl#LL53-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecursivePartition.index_pcbmat-Tuple{Array{Float64,2},Array{MVPIndex,1},Array{Float64,2}}" href="#RecursivePartition.index_pcbmat-Tuple{Array{Float64,2},Array{MVPIndex,1},Array{Float64,2}}"><code>RecursivePartition.index_pcbmat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">index_pcbmat(X::Matrix{Float64}, indices::Vector{MVPIndex}, kmat::Matrix{Float64})</code></pre><p>Compute the Polynomial Chaos Basis (PCB) expansion for each row of <code>X</code> for specified indices (generated using <a href="#RecursivePartition.mvpindex-Tuple{Int64,Int64}"><code>mvpindex</code></a>).</p><p>Legendre Polynomials are used as basis functions, hence an additional argument <code>kmat</code> is supplied to rescale the columns of <code>X</code> back on to <span>$[-1, 1]$</span>.</p><p>See also: <a href="#RecursivePartition.mvpindex-Tuple{Int64,Int64}"><code>mvpindex</code></a>, <a href="#RecursivePartition.MVPIndex"><code>MVPIndex</code></a>, <a href="#RecursivePartition.trunc_pcbmat-Tuple{Array{Float64,2},Int64,Array{Float64,2}}"><code>trunc_pcbmat</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">X = [-0.5 0.5; 0.1 0.2]
kmat = repeat([-1.0 1.0], 2, 1)
ind = mvpindex(2, 2)

index_pcbmat(X, ind, kmat)

# output

2×5 Array{Float64,2}:
 0.5  -0.125  -0.5  -0.25  -0.125
 0.2  -0.44    0.1   0.02  -0.485</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dfcorbin/RecursivePartition.jl/blob/baed2bfb0913c5fbabb6e36014602956b47f7819/src/pcb.jl#LL154-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecursivePartition.mvpindex-Tuple{Int64,Int64}" href="#RecursivePartition.mvpindex-Tuple{Int64,Int64}"><code>RecursivePartition.mvpindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mvpindex(dim::Int64, degmax::Int64)</code></pre><p>Generate a vector containing all possible <a href="#RecursivePartition.MVPIndex"><code>MVPIndex</code></a> objects subject to a bound, <code>degmax</code>, on the total degree of each multivariate polynomial.</p><p>The total degree of a multivariate polynomial is defined as the sum of each individual multiplicative term&#39;s degree i.e. <span>$\text{deg}(x_1^2 x_2^3) = 2 + 3 = 5$</span></p><p>See also: <a href="#RecursivePartition.index_pcbmat-Tuple{Array{Float64,2},Array{MVPIndex,1},Array{Float64,2}}"><code>index_pcbmat</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia"># Output all 2-dimensional MVPs with total degree less than 2.

mvpindex(2, 2)

# output

5-element Array{MVPIndex,1}:
 MVPIndex([1], [2])
 MVPIndex([2], [2])
 MVPIndex([1], [1])
 MVPIndex([1, 1], [1, 2])
 MVPIndex([2], [1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dfcorbin/RecursivePartition.jl/blob/baed2bfb0913c5fbabb6e36014602956b47f7819/src/pcb.jl#LL111-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecursivePartition.trunc_pcbmat-Tuple{Array{Float64,2},Int64,Array{Float64,2}}" href="#RecursivePartition.trunc_pcbmat-Tuple{Array{Float64,2},Int64,Array{Float64,2}}"><code>RecursivePartition.trunc_pcbmat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trunc_pcbmat(X::Matrix{Float64}, degmax::Int64, kmat::Matrix{Float64})</code></pre><p>Compute the Polynomial Chaos Basis (PCB) using the full truncated PCB basis.</p><p>Legendre Polynomials are used as basis functions, hence an additional argument <code>kmat</code> is supplied to rescale the columns of <code>X</code> back on to <span>$[-1, 1]$</span>.</p><p>See also: <a href="#RecursivePartition.mvpindex-Tuple{Int64,Int64}"><code>mvpindex</code></a>, <a href="#RecursivePartition.MVPIndex"><code>MVPIndex</code></a>, <a href="#RecursivePartition.index_pcbmat-Tuple{Array{Float64,2},Array{MVPIndex,1},Array{Float64,2}}"><code>index_pcbmat</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">X = [-0.5 0.5; 0.1 0.2]
kmat = repeat([-1.0 1.0], 2, 1)

trunc_pcbmat(X, 2, kmat)

# output

2×5 Array{Float64,2}:
 0.5  -0.125  -0.5  -0.25  -0.125
 0.2  -0.44    0.1   0.02  -0.485</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dfcorbin/RecursivePartition.jl/blob/baed2bfb0913c5fbabb6e36014602956b47f7819/src/pcb.jl#LL195-L219">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../legendre/">« Legendre Polynomials</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 8 January 2021 14:19">Friday 8 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
