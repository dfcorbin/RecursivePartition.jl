var documenterSearchIndex = {"docs":
[{"location":"pcb/#Polynomial-Chaos-Basis","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"","category":"section"},{"location":"pcb/#Definition","page":"Polynomial Chaos Basis","title":"Definition","text":"","category":"section"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"The Polynomial Chaos Basis (PCB) is a natural way of extending univariate polynomial bases to the multivariate setting. I will provide a brief introduction to the PCB and how it is constructed, but I will make no attempt to motivate its applications. Upon completion of this documentation I will reference a more detailed summary of PCB applications and theoretical properties.","category":"page"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"Let ϕ_j(x) denote a univariate polynomial of degree j in mathbbN_ 0  e.g. ϕ_2(x) = x^2 using the Power Basis. We use this notation as there are other univariate bases to choose from, some of which possess useful theoretical properties like orthogonality (see Legendre Polynomials). One way of defining a multivariate polynomial (MVP) is to take a multiplicative combination of univariate polynomials. This can be indexed using a vector of non-negative integers as follows. Let boldsymbolα = 1 3 5, the corresponding 3-dimensional multivariate polynomial is given by","category":"page"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"  psi_boldsymbolα(boldsymbolx) = ϕ_1(x_1) cdot ϕ_3(x_2) cdot ϕ_5(x_3)","category":"page"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"The d-dimensional PCB is then defined as the collection of all MVPs which can be indexed in this way.","category":"page"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"  lbrace ψ_boldsymbolα quad  quad boldsymbolα in mathbbN_ 0^d rbrace","category":"page"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"However, in practice this basis must be truncated in order to be used. This can be achieved by restricting the total degree (defined as the sum of the elements in boldsymbolα)) of the MVPs.","category":"page"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"  lbrace ψ_boldsymbolalpha quad  quad boldsymbolalpha_1 leqq J\n  text  boldsymbolalpha in mathbbN_geqq 0^d rbrace","category":"page"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"Now suppose you have an n times d matrix boldsymbolX of real numbers. Each row of boldsymbolX is a vector on which we can evaluate a MVP. We can therefore construct a new matrix where the entry in the i'th row and j'th column is the i'th row of boldsymbolX evaluated at the j'th basis function in our PCB i.e. each column of the transformed matrix corresponds to a different MVP in the truncated PCB. This matrix is what we refer to as the \"PCB expansion\" of boldsymbolX.","category":"page"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"boldsymbolΨ_ij = ψ_boldsymbolα_j(boldsymbolx_i)","category":"page"},{"location":"pcb/#Implementation-Details","page":"Polynomial Chaos Basis","title":"Implementation Details","text":"","category":"section"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"Currently, I have only implemented the Legendre Polynomials variant of the PCB. Since the Legendre Polynomials are only defined on -1 1, the user must provide upper/lower bounds for each column of boldsymbolX (it is assumed that each column is uniformly distributed between these bounds). These bounds are used to rescale the columns so that they are all uniformly distributed on -1 1. Bounds are provided as a d times 2 matrix. For example, if d = 2, x_1 in 0 1 and x_2 in 1 2, the bounds are represented as","category":"page"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"beginpmatrix\n  0  1 \n  1  2\nendpmatrix","category":"page"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"Constructing the PCB expansion of a matrix using RecursivePartition.trunc_pcbmat is then straightforward.","category":"page"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"using RecursivePartition\n\nX = [0.0 0.5; -0.5 0.0]\nkmat = repeat([-1.0 1.0], 2, 1)\n\ntrunc_pcbmat(X, 2, kmat)\n\n# output\n\n2×5 Array{Float64,2}:\n 0.5  -0.125   0.0   0.0  -0.5\n 0.0  -0.5    -0.5  -0.0  -0.125","category":"page"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"If there are specific MVPs you wish to use in the basis expansion (as opposed to the full truncated PCB), this is achieved using RecursivePartition.index_pcbmat. This function accepts a vector of RecursivePartition.MVPIndex objects which correspond to your choice of MVPs. To construct such an object, we supply two vectors of even length, the first gives the degree of each multiplicative term in the MVP, the second gives the covariate it applies to. For example, to store the MVP","category":"page"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"ϕ_1(x_1)  ϕ_3(x_2)","category":"page"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"we create the object","category":"page"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"MVPIndex([1, 3], [1, 2])","category":"page"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"This may seem like an odd method for storing an MVP, but it turns out to be far more memory efficient than other methods in higher dimensions. As an alternative to manually constructing RecursivePartition.MVPIndex objects, you can generate the full truncated PCB basis using RecursivePartition.mvpindex and select the basis functions you wish to use.","category":"page"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"mvpindex(2, 2) # 2D PCB basis trunacted with J = 2\n\n# output\n\n5-element Array{MVPIndex,1}:\n MVPIndex([1], [2])\n MVPIndex([2], [2])\n MVPIndex([1], [1])\n MVPIndex([1, 1], [1, 2])\n MVPIndex([2], [1])","category":"page"},{"location":"pcb/#Functions","page":"Polynomial Chaos Basis","title":"Functions","text":"","category":"section"},{"location":"pcb/","page":"Polynomial Chaos Basis","title":"Polynomial Chaos Basis","text":"Modules = [RecursivePartition]\nPages = [\"pcb.jl\"]","category":"page"},{"location":"pcb/#RecursivePartition.MVPIndex","page":"Polynomial Chaos Basis","title":"RecursivePartition.MVPIndex","text":"MVPIndex(deg::Vector{Int64}, dim::Vector{Int64})\n\nCompact structure used to index a multivariate polynomial (MVP).\n\nIt is assumed that this type is primarily constructed using mvpindex and supplied to index_pcbmat to perform a polynomial basis expansion.\n\ndeg gives the degree of each multiplicative term in the MVP.\ndim gives the covariate associated with each degree.\n\nSee also: mvpindex, index_pcbmat\n\nExamples\n\nLet's suppose we have the vector boldsymbolx = x_1 x_2 and we wish to index the multivariate polynomial x_1^2 x_2^3. This is achieved using the following object.\n\nMVPIndex([2, 3], [1, 2])\n\n\n\n\n\n","category":"type"},{"location":"pcb/#RecursivePartition.index_pcbmat-Tuple{Array{Float64,2},Array{MVPIndex,1},Array{Float64,2}}","page":"Polynomial Chaos Basis","title":"RecursivePartition.index_pcbmat","text":"index_pcbmat(X::Matrix{Float64}, indices::Vector{MVPIndex}, kmat::Matrix{Float64})\n\nCompute the Polynomial Chaos Basis (PCB) expansion for each row of X for specified indices (generated using mvpindex).\n\nLegendre Polynomials are used as basis functions, hence an additional argument kmat is supplied to rescale the columns of X back on to -1 1.\n\nSee also: mvpindex, MVPIndex, trunc_pcbmat\n\nExamples\n\nX = [-0.5 0.5; 0.1 0.2]\nkmat = repeat([-1.0 1.0], 2, 1)\nind = mvpindex(2, 2)\n\nindex_pcbmat(X, ind, kmat)\n\n# output\n\n2×5 Array{Float64,2}:\n 0.5  -0.125  -0.5  -0.25  -0.125\n 0.2  -0.44    0.1   0.02  -0.485\n\n\n\n\n\n","category":"method"},{"location":"pcb/#RecursivePartition.mvpindex-Tuple{Int64,Int64}","page":"Polynomial Chaos Basis","title":"RecursivePartition.mvpindex","text":"mvpindex(dim::Int64, degmax::Int64)\n\nGenerate a vector containing all possible MVPIndex objects subject to a bound, degmax, on the total degree of each multivariate polynomial.\n\nThe total degree of a multivariate polynomial is defined as the sum of each individual multiplicative term's degree i.e. textdeg(x_1^2 x_2^3) = 2 + 3 = 5\n\nSee also: index_pcbmat\n\nExamples\n\n# Output all 2-dimensional MVPs with total degree less than 2.\n\nmvpindex(2, 2)\n\n# output\n\n5-element Array{MVPIndex,1}:\n MVPIndex([1], [2])\n MVPIndex([2], [2])\n MVPIndex([1], [1])\n MVPIndex([1, 1], [1, 2])\n MVPIndex([2], [1])\n\n\n\n\n\n","category":"method"},{"location":"pcb/#RecursivePartition.trunc_pcbmat-Tuple{Array{Float64,2},Int64,Array{Float64,2}}","page":"Polynomial Chaos Basis","title":"RecursivePartition.trunc_pcbmat","text":"trunc_pcbmat(X::Matrix{Float64}, degmax::Int64, kmat::Matrix{Float64})\n\nCompute the Polynomial Chaos Basis (PCB) using the full truncated PCB basis.\n\nLegendre Polynomials are used as basis functions, hence an additional argument kmat is supplied to rescale the columns of X back on to -1 1.\n\nSee also: mvpindex, MVPIndex, index_pcbmat\n\nExamples\n\nX = [-0.5 0.5; 0.1 0.2]\nkmat = repeat([-1.0 1.0], 2, 1)\n\ntrunc_pcbmat(X, 2, kmat)\n\n# output\n\n2×5 Array{Float64,2}:\n 0.5  -0.125  -0.5  -0.25  -0.125\n 0.2  -0.44    0.1   0.02  -0.485\n\n\n\n\n\n","category":"method"},{"location":"partition/#Recursive-Partitioning","page":"Recursive Partitioning","title":"Recursive Partitioning","text":"","category":"section"},{"location":"partition/","page":"Recursive Partitioning","title":"Recursive Partitioning","text":"The RecursivePartition module allows the user to partition data into (hyper-)rectangular subsets across a bounded space. I will start with a simple motivating example which demonstrates the partitioning functionality of this module. Suppose that you have a dataset containing 1000 pairs of coordinates which exist between 0 and 1 i.e. all of the points are positioned somewhere within the unit square. This information can be encoded using a matrix, where the i'th row details the upper/lower bounds of the i'th coordinate. Our square is therefore represented by the matrix","category":"page"},{"location":"partition/","page":"Recursive Partitioning","title":"Recursive Partitioning","text":"beginpmatrix\n  0  1 \n  0  1 \nendpmatrix","category":"page"},{"location":"partition/","page":"Recursive Partitioning","title":"Recursive Partitioning","text":"One way to approach dividing up this space is to simply split the square in half and determine which side each of the points falls on. Assuming we are splitting in dimension 1 (or the x-direction in terms of coordinates), this would look something like this:","category":"page"},{"location":"partition/","page":"Recursive Partitioning","title":"Recursive Partitioning","text":"(Image: Partition Demo 1)","category":"page"},{"location":"partition/","page":"Recursive Partitioning","title":"Recursive Partitioning","text":"We can now represent this as a vector of matrices, each matrix corresponding to a separate subregion.","category":"page"},{"location":"partition/","page":"Recursive Partitioning","title":"Recursive Partitioning","text":"P = left\nbeginpmatrix\n  0  05 \n  0  1\nendpmatrix\nbeginpmatrix\n  05  0 \n  0    1\nendpmatrix\nright","category":"page"},{"location":"partition/","page":"Recursive Partitioning","title":"Recursive Partitioning","text":"We can continue to recursively partition the resulting subsets into smaller rectangles e.g.","category":"page"},{"location":"partition/","page":"Recursive Partitioning","title":"Recursive Partitioning","text":"(Image: Partition Demo 2)","category":"page"},{"location":"partition/","page":"Recursive Partitioning","title":"Recursive Partitioning","text":"Partitions defined in this way can be constructed using RecursivePartition.insert_knot.","category":"page"},{"location":"partition/","page":"Recursive Partitioning","title":"Recursive Partitioning","text":"using RecursivePartition\n\nX = rand(1000, 2)\nP = [repeat([0.0 1.0], 2, 1)]\nP = insert_knot(P, 1, 1, 0.5) # Split in dimension 1.\nP = insert_knot(P, 1, 2, 0.5) # Split subregion 1 in dimension 2.\nXsubsets = partition(X, P) # Partition X according to P.","category":"page"},{"location":"partition/","page":"Recursive Partitioning","title":"Recursive Partitioning","text":"The output Xsubsets is a vector of matrices; each matrix contains the rows of X pertaining to a particular subset. Although it is convenient to visualize this process in 2D, it is easily extended to higher dimensions.","category":"page"},{"location":"partition/#Functions","page":"Recursive Partitioning","title":"Functions","text":"","category":"section"},{"location":"partition/","page":"Recursive Partitioning","title":"Recursive Partitioning","text":"Modules = [RecursivePartition]\nPages = [\"partition.jl\"]","category":"page"},{"location":"partition/#RecursivePartition.insert_knot!-Tuple{Array{Array{Float64,2},1},Int64,Int64,Float64}","page":"Recursive Partitioning","title":"RecursivePartition.insert_knot!","text":"insert_knot!(P::Vector{Matrix{Float64}}, k::Int64, dim::Int64, loc::Float64)\n\nDo insert_knot by overwriting the original array (memory efficient).\n\n\n\n\n\n","category":"method"},{"location":"partition/#RecursivePartition.insert_knot-Tuple{Array{Array{Float64,2},1},Int64,Int64,Float64}","page":"Recursive Partitioning","title":"RecursivePartition.insert_knot","text":"insert_knot(P::Vector{Matrix{Float64}}, k::Int64, dim::Int64, loc::Float64)\n\nBisect the k'th subset along dimension dim.\n\nThis function returns a modified version of P, where the k'th subset is replaced by the two matrices outputted by splitmat.\n\nSee also: splitmat, insert_knot!\n\nExamples\n\nP = [repeat([-1.0 1.0], 2, 1)]\nP1 = insert_knot(P, 1, 1, 0.0)\n\n# output\n\n2-element Array{Array{Float64,2},1}:\n [-1.0 0.0; -1.0 1.0]\n [0.0 1.0; -1.0 1.0]\n\n\n\n\n\n","category":"method"},{"location":"partition/#RecursivePartition.partition-Tuple{Array{Float64,2},Array{Array{Float64,2},1},Array{Float64,1},Array{Float64,1}}","page":"Recursive Partitioning","title":"RecursivePartition.partition","text":"partition(X, P, [, y]; track=false)\n\nPartition a data matrix X (and optional vector y) into subsets according to a partition P.\n\nSee also: which_subset\n\nExamples\n\nP = [repeat([-1.0 1.0], 2, 1)]\nP = insert_knot!(P, 1, 1, 0.0)\nX = [-0.5 0.0; 0.5 0.0]\ny = [1.0, 2.0]\npartition(X, P, y; track=true)\n\n# output\n\n([[-0.5 0.0], [0.5 0.0]], [[1.0], [2.0]], [[1], [2]])\n\n\n\n\n\n","category":"method"},{"location":"partition/#RecursivePartition.splitmat-Tuple{Array{Float64,2},Int64,Float64}","page":"Recursive Partitioning","title":"RecursivePartition.splitmat","text":"splitmat(mat::Matrix{Float64}, dim::Int64, loc::Float64)\n\nReturn two new matrices that result from splitting row dim at loc.\n\nmat must have exactly two columns, with column two being strictly greater than column 1. loc must be contained by the row to be split.\n\n\n\n\n\n","category":"method"},{"location":"partition/#RecursivePartition.which_subset-Tuple{Array{Float64,1},Array{Array{Float64,2},1}}","page":"Recursive Partitioning","title":"RecursivePartition.which_subset","text":"which_subset(x::Vector{Float64}, P::Vector{Matrix{Float64}})\n\nDetermine which subset a vector x is contained by. This function assumes that your partition P is disjoint and comprises the entire space under union.\n\nExamples\n\nP = [repeat([-1.0 1.0], 2, 1)]\ninsert_knot!(P, 1, 1, 0.0) # Create two daughter subsets by dividing dim 1.\nx = [-0.5, 0.0] # Dim 1 is les than 0.\n\nwhich_subset(x, P)\n\n# output\n\n1\n\n\n\n\n\n","category":"method"},{"location":"legendre/#Legendre-Polynomials","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"","category":"section"},{"location":"legendre/#Tutorial","page":"Legendre Polynomials","title":"Tutorial","text":"","category":"section"},{"location":"legendre/","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"The Legendre Polynomials are a set of univariate polynomials defined on the interval -1 1. Let \nϕ_j(x)  -1 1  mathbbR denote the order j in mathbbN_0 Legendre Polynomial. The Legendre Polynomials are defined by the property","category":"page"},{"location":"legendre/","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"_-1^1 ϕ_i(x) ϕ_j(x) dx = 0 quad textfor all  i  j quad ϕ_0(x) = 1","category":"page"},{"location":"legendre/","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"This property is referred to orthogonality. The theoretical benefits of orthogonality are beyond the scope of this documentation. For more detailed information about the theoretical properties of the Legendre Polynomials, see here. It turns out that Legendre polynomials can be defined by the second order recursive equation","category":"page"},{"location":"legendre/","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"(n + 1) ϕ_n + 1(x) = (2 n + 1) x ϕ_n(x) - n ϕ_n - 1(x)","category":"page"},{"location":"legendre/","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"We prodive two simple methods for evaluating Legendre Polynomials. The simplest approach is by using RecursivePartition.legendre_poly.","category":"page"},{"location":"legendre/","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"using RecursivePartition\n\nlegendre_poly(5, 0.5) # 5th order Legendre Polynomial evaluated as x = 0.5\n\n# output\n\n0.08984375","category":"page"},{"location":"legendre/","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"However, often the user wants to evaluate the Legendre Polynomials for a range of values e.g. j = 0 ldots 5. In this case, I recommend using the recursive definintion (RecursivePartition.legendre_next) directly.","category":"page"},{"location":"legendre/","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"lp = Vector{Float64}(undef, 6)\nlp[1:2] = [1.0, 0.5]  # Must ϕ_0(x) and ϕ_1(x) as a start.\n\nfor j in 3:6 # Remember we are starting from order 0.\n  lp[j] = legendre_next(j - 1, 0.5, lp[j - 1], lp[j - 2])\nend\n\nlp\n\n# output\n\n6-element Array{Float64,1}:\n  1.0\n  0.5\n -0.125\n -0.4375\n -0.2890625\n  0.08984375","category":"page"},{"location":"legendre/#Functions","page":"Legendre Polynomials","title":"Functions","text":"","category":"section"},{"location":"legendre/","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"Modules = [RecursivePartition]\nPages = [\"legendre.jl\"]","category":"page"},{"location":"legendre/#RecursivePartition.legendre_next-Tuple{Int64,Float64,Float64,Float64}","page":"Legendre Polynomials","title":"RecursivePartition.legendre_next","text":"legendre_next(ord, x, d1, d0)\n\nRecursive definition of the Legendre polynomials.\n\nThe Legendre Polynomials are defined as second order recursive equation, meaning computing an order n  2 Legendre Polynomial is possible if we know the corresponding order n - 1 and n - 2 evaluations. These are supplied in the arguments d1 and d0 (note that the order 1 and 0 evaluations are always equal to x and 1.0 respectively).\n\nSee also: legendre_poly\n\nExamples\n\nord = 2\nx = 1.0\nd1 = 1.0\nd0 = 1.0\n\nlegendre_next(ord, x, d1, d0)\n\n# output\n\n1.0\n\n\n\n\n\n","category":"method"},{"location":"legendre/#RecursivePartition.legendre_poly-Tuple{Int64,Float64}","page":"Legendre Polynomials","title":"RecursivePartition.legendre_poly","text":"legendre_poly(ord, x)\n\nReturn the Legendre polynomial of specified order (ord) evaluated at x.\n\nSee also: legendre_next\n\nExamples\n\nlegendre_poly(1, 1.0)\n\n# output\n\n1.0\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = RecursivePartition","category":"page"},{"location":"#RecursivePartition","page":"Home","title":"RecursivePartition","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
